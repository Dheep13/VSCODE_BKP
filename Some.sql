-- tables KYN_
-- library KYN_LIB_
-- proc KYN_SP_
-- func KYN_FNC_

-- check with Stefan on sprint deliverable
-- add the library for pipeline runs

-- Deepan is 5.5 hours diff

-- tracking table
drop table ext.kyn_tq2com_sync;

create table ext.kyn_tq2com_sync (
run_key bigint not null primary key generated by default as identity,
run_date timestamp default current_timestamp,
process_flag tinyint default 0 not null,
territoryprogramseq bigint not null,
territoryprogram_name varchar(127),
territoryprogram_esd date,
territoryprogram_eed date,
territoryprogram_periodtype varchar(50),
territoryprogram_calendar varchar(50),
territoryprogram_periodseq bigint,
territoryprogram_period varchar(50),
semiannual_periodseq bigint,
semiannual_name varchar(50)
);

-- workflow or trigger adds entries to tracking table
insert into ext.kyn_tq2com_sync (
territoryprogramseq, 
territoryprogram_name,
territoryprogram_esd,
territoryprogram_eed,
territoryprogram_periodtype,
territoryprogram_calendar,
territoryprogram_periodseq,
territoryprogram_period)
select 
tp.territoryprogramseq, 
tp.name, 
cast(tp.effectivestartdate as date) as esd,
cast(tp.effectiveenddate as date) as eed,
pt.name as periodtype,
cal_tp.name as calendar,
per_tp.periodseq as periodseq,
per_tp.name as period
from csq_territoryprogram tp
join cs_periodtype pt on tp.periodtypeseq = pt.periodtypeseq and pt.removedate= '2200-01-01'
join cs_period per_tp on tp.periodseq = per_tp.periodseq and per_tp.removedate= '2200-01-01'
join cs_calendar cal_tp on per_tp.calendarseq = cal_tp.calendarseq and cal_tp.removedate = '2200-01-01'
where tp.removedate = '2200-01-01'
and tp.name = 'FY24H1_AM_Seller_WW_DI';

-- set semi annual details and batch
update ext.kyn_tq2com_sync x
set (x.semiannual_periodseq, x.semiannual_name) = (
	select y.periodseq, y.name from cs_period y
	where y.removedate = '2200-01-01'
	and y.parentseq = x.territoryprogram_periodseq
	and ((y.name like 'HY1%' and x.territoryprogram_name like 'FY__H1%') or (y.name like 'HY2%' and x.territoryprogram_name like 'FY__H2%'))
);

-- filter table - TODO
create table ext.kyn_tq2com_filter (
run_key bigint,
filter_column varchar(255), -- e.g. positionName
filter_value nvarchar(255) -- e.g. POS1234
);




-- create table with quotas from the programs
drop table ext.KYN_TQ2Com_TQ_Quota;

create table ext.kyn_tq2com_tq_quota as (
select
  jc.run_key,
  t.name as territory_name,
  cast(t.effectivestartdate as date) as territory_esd,
  cast(t.effectiveenddate as date) as territory_eed,  
  tt.targettypeid,
  cast(tq.effectivestartdate as date) as quota_esd,
  cast(tq.effectiveenddate as date) as quota_eed,  
  tq.quotavalue,
  ut_tq.name as unittype,
  tq.finalquotavalue,
  tq.casestatus as quota_casestatus,
  cast(tpos.effectivestartdate as date) as tpos_esd,
  cast(tpos.effectiveenddate as date) as tpos_eed,
  tpos.split,
  tpos.positionseq,
  pos.name as position,
  pos.payeeseq,
  pay.payeeid
from ext.kyn_tq2com_sync jc
join csq_territory t on 
  jc.territoryprogramseq = t.territoryprogramseq
  and t.removedate = '2200-01-01'
  and t.effectivestartdate < jc.territoryprogram_eed
  and t.effectiveenddate > jc.territoryprogram_esd
join csq_territoryquota tq on 
  tq.territoryseq = t.territoryseq 
  and tq.removedate= '2200-01-01' 
  and tq.effectivestartdate < t.effectiveenddate
  and tq.effectiveenddate > t.effectivestartdate 
join csq_targettype tt on tq.targettypeseq = tt.datatypeseq and tt.removedate= '2200-01-01'
join cs_unittype ut_tq on tq.unittypeforquotavalue = ut_tq.unittypeseq and ut_tq.removedate = '2200-01-01'
join csq_territoryposition tpos on 
  tpos.territoryseq = t.territoryseq 
  and tpos.removedate = '2200-01-01' 
  and tpos.effectivestartdate < t.effectiveenddate
  and tpos.effectiveenddate > t.effectivestartdate 
join cs_position pos on 
  tpos.positionseq = pos.ruleelementownerseq 
  and pos.removedate = '2200-01-01'
  and pos.effectivestartdate < tpos.effectiveenddate
  and pos.effectiveenddate >= tpos.effectiveenddate
join cs_payee pay on
  pos.payeeseq = pay.payeeseq
  and pay.removedate = '2200-01-01'
  and pay.effectivestartdate < pos.effectiveenddate
  and pay.effectiveenddate >= pos.effectiveenddate
where jc.process_flag = 0
);

-- create a prestage table
drop table  ext.KYN_TQ2Com_Prestage_Quota;

create table ext.kyn_tq2com_prestage_quota as (
select * from (
select
qs.run_key,
qs.semiannual_periodseq,
qs.semiannual_name,
cast(0 as tinyint) as active_flag,
cast(null as timestamp) as active_start,
cast(null as timestamp) as active_end,
per.startdate as effectivestartdate,
per.enddate as effectiveenddate,
case jc.targettypeid
when 'GP' then 'Q_Profit'
else 'Q_'||jc.targettypeid
end as quotaname,
sum(jc.quotavalue) as value,
jc.unittype as unittypeforvalue,
pt.name as periodtypename,
null as businessunitmap,
jc.positionseq,
jc.position as positionname,
null as batchname
from ext.kyn_tq2com_tq_quota jc
join ext.kyn_tq2com_sync qs on jc.run_key = qs.run_key
join cs_period per on qs.semiannual_periodseq = per.periodseq and per.removedate = '2200-01-01'
join cs_periodtype pt on per.periodtypeseq = pt.periodtypeseq and pt.removedate = '2200-01-01'
where qs.process_flag = 0
group by qs.run_key, qs.semiannual_periodseq, qs.semiannual_name, per.startdate, per.enddate, jc.targettypeid, jc.unittype, pt.name, jc.positionseq, jc.position
) x
where exists (select 1 from cs_quota q where q.removedate ='2200-01-01' and x.quotaname = q.name)
);



-- accounts
drop table ext.kyn_tq2com_account;

create table ext.kyn_tq2com_account as (
select
  qs.run_key,
  qs.semiannual_periodseq,
  qs.semiannual_name,
  cast(0 as tinyint) as active_flag,
  cast(null as timestamp) as active_start,
  cast(null as timestamp) as active_end,
  t.name as territory,
  cast(t.effectivestartdate as date) t_esd,
  cast(t.effectiveenddate as date) t_eed,
  tpos.positionseq,
  pos.name as position,
  cast(pos.effectivestartdate as date) pos_esd,
  cast(pos.effectiveenddate as date) pos_eed,
  cast(tacc.effectivestartdate as date) tacc_esd,
  cast(tacc.effectiveenddate as date) tacc_edd,
  acc.accountid,
  tacc.isaddedduetoparent
from ext.kyn_tq2com_sync qs
join csq_territory t on 
  qs.territoryprogramseq = t.territoryprogramseq
  and t.removedate = '2200-01-01'
  and t.effectivestartdate < qs.territoryprogram_eed
  and t.effectiveenddate > qs.territoryprogram_esd
join csq_territoryaccount tacc on
  tacc.territoryseq = t.territoryseq
  and tacc.removedate = '2200-01-01'
  and tacc.effectivestartdate < t.effectiveenddate
  and tacc.effectiveenddate > t.effectivestartdate  
join csq_account acc on
  acc.accountseq = tacc.accountseq
  and acc.removedate = '2200-01-01'
  and acc.effectivestartdate < tacc.effectiveenddate
  and acc.effectiveenddate > tacc.effectivestartdate
join csq_territoryposition tpos on 
  tpos.territoryseq = t.territoryseq 
  and tpos.removedate = '2200-01-01'
  and tpos.effectivestartdate < t.effectiveenddate
  and tpos.effectiveenddate > t.effectivestartdate
join cs_position pos on 
  tpos.positionseq = pos.ruleelementownerseq 
  and pos.removedate = '2200-01-01'
  and pos.effectivestartdate < tpos.effectiveenddate
  and pos.effectiveenddate > tpos.effectivestartdate
where qs.process_flag = 0
);


-- products
drop table ext.kyn_tq2com_product;

create table ext.kyn_tq2com_product as (
select
qs.run_key,
qs.semiannual_periodseq,
qs.semiannual_name,
cast(0 as tinyint) as active_flag,
cast(null as timestamp) as active_start,
cast(null as timestamp) as active_end,
t.name as territory,
cast(t.effectivestartdate as date) t_esd, 
cast(t.effectiveenddate as date) t_eed,
tpos.positionseq,
pos.name as position,
cast(pos.effectivestartdate as date) pos_esd, 
cast(pos.effectiveenddate as date) pos_eed,
cast(tprd.effectivestartdate as date) tprd_esd, 
cast(tprd.effectiveenddate as date) tprd_edd,
cat.name as category,
prd.classifierid,
tprd.source,
cast(0 as tinyint) as process_flag
from ext.kyn_tq2com_sync qs
join csq_territory t on 
  qs.territoryprogramseq = t.territoryprogramseq
  and t.removedate = '2200-01-01'
  and t.effectivestartdate < qs.territoryprogram_eed
  and t.effectiveenddate > qs.territoryprogram_esd
join csq_territoryproduct tprd on
  tprd.territoryseq = t.territoryseq
  and tprd.removedate = '2200-01-01'
  and tprd.effectivestartdate < t.effectiveenddate
  and tprd.effectiveenddate > t.effectivestartdate      
join cs_classifier prd on 
  prd.classifierseq = tprd.productseq
  and prd.removedate = '2200-01-01'
  and prd.effectivestartdate < tprd.effectiveenddate
  and prd.effectiveenddate > tprd.effectivestartdate   
left outer join cs_category cat on 
  tprd.categoryseq = cat.ruleelementseq
  and cat.removedate = '2200-01-01'
  and cat.effectivestartdate < tprd.effectiveenddate
  and cat.effectiveenddate > tprd.effectivestartdate
join csq_territoryposition tpos on 
  tpos.territoryseq = t.territoryseq 
  and tpos.removedate = '2200-01-01'
  and tpos.effectivestartdate < t.effectiveenddate
  and tpos.effectiveenddate > t.effectivestartdate
join cs_position pos on 
  tpos.positionseq = pos.ruleelementownerseq 
  and pos.removedate = '2200-01-01'
  and pos.effectivestartdate < tpos.effectiveenddate
  and pos.effectiveenddate > tpos.effectivestartdate  
where qs.process_flag = 0);



-- when the IPL runs it must pull the latest details from the tables
-- there needs to be 2 formulas - one for HY and another for Y
-- the query for value will pass to the function the period details for the end date of the distribution 
-- quota for semiannual
select * 
from ext.kyn_tq2com_prestage_quota q
where q.run_key = (
  select max(q1.run_key)
  from ext.kyn_tq2com_prestage_quota q1 
  where q.positionname = q1.positionname
  and q.semiannual_periodseq = q1.semiannual_periodseq)
and q.positionname = '5009345_GermanSchmidt_01'
order by 2;

-- accounts for semiannual
select * 
from ext.kyn_tq2com_account a
where a.run_key = (
  select max(q1.run_key)
  from ext.kyn_tq2com_prestage_quota q1 
  where a.position = q1.positionname
  and a.semiannual_periodseq = q1.semiannual_periodseq)
and a.position = '5009345_GermanSchmidt_01'
order by 2;
;

-- products for semiannual
select * 
from ext.kyn_tq2com_product p
where p.run_key = (
  select max(q1.run_key)
  from ext.kyn_tq2com_prestage_quota q1 
  where p.position = q1.positionname
  and p.semiannual_periodseq = q1.semiannual_periodseq)
and p.position = '5009345_GermanSchmidt_01'
order by 2;
;

-- IPL trace
drop table ext.kyn_tq2com_ipl_trace;

create table ext.kyn_tq2com_ipl_trace as (
select
dp.documentprocessseq, dp.generatedate, dp.name, dp.batchname, dp.startdate, dp.enddate,
dp.positionseq, pos.name as position, dp.status, dp.acceptdate,
per.periodseq as semiannual_periodseq,
per.name as semiannual_name,
cast(null as bigint) as run_key,
cast(0 as tinyint) as process_flag
from csp_documentprocess dp
join cs_position pos on 
  dp.positionseq = pos.ruleelementownerseq 
  and pos.removedate = '2200-01-01' 
  and pos.effectivestartdate < dp.enddate 
  and pos.effectiveenddate >= dp.enddate
join cs_period per on
  per.startdate >= dp.startdate
  and per.enddate <= dp.enddate
  and per.removedate = '2200-01-01'
join cs_periodtype pt on
  per.periodtypeseq = pt.periodtypeseq 
  and pt.removedate = '2200-01-01'
  and pt.name = 'semiannual' 
where exists (
  -- must be for a plan document
  select 1
  from csp_documentassignment da
  join csp_documenttemplate dt on da.documenttemplateseq = dt.documenttemplateseq and dt.removedate = '2200-01-01'
  join csp_documenttype dty on dt.documenttypeseq = dty.datatypeseq and dty.removedate = '2200-01-01'
  where dp.documentprocesstemplateseq = da.documentprocesstemplateseq 
  and da.removedate = '2200-01-01'
  and dty.datatype = 'Plan'
)
--and not exists (select 1 from ext.kyn_tq2com_ipl_trace x where x.documentprocessseq = dp.documentprocessseq)
);


-- set run_key
update ext.kyn_tq2com_ipl_trace ipl
set ipl.run_key = (
select max(s.run_key)
from
ext.kyn_tq2com_sync s
join ext.kyn_tq2com_tq_quota q on s.run_key = q.run_key
where s.semiannual_periodseq = ipl.semiannual_periodseq
and q.positionseq = ipl.positionseq
and s.run_date <= ipl.generatedate
);

-- refresh status
update ext.kyn_tq2com_ipl_trace x
set (x.status, x.acceptdate) = (select y.status, y.acceptdate from csp_documentprocess y where x.documentprocessseq = y.documentprocessseq)
where process_flag = 0 and run_key is not null;



-- load stagequota for accepted IPL
insert into cs_stagequota
(tenantid, stagequotaseq, effectivestartdate, effectiveenddate, quotaname, value, unittypeforvalue, periodtypename, businessunitmap, positionname, batchname, stageprocessflag, description)
select '1681' as tenantid,
(select max(stagequotaseq) from cs_stagequota) + row_number() over (order by quotaname, positionname) as stagequotaseq,
q.effectivestartdate, q.effectiveenddate, q.quotaname, q.value, 
q.unittypeforvalue, q.periodtypename, q.businessunitmap, q.positionname, 
'TQ2COM_'||TO_CHAR(current_timestamp,'YYYYMMDD_HH24MISS') as batchname, -- need to set the batchname
0 as stageprocessflag, 
null as description
from ext.kyn_tq2com_prestage_quota q
join ext.kyn_tq2com_ipl_trace ipl on q.run_key = ipl.run_key and q.positionseq = ipl.positionseq
where ipl.process_flag = 0
and ipl.status = 'status_Accepted';

/*
-- set active flag and dates on kyn_tq2com_prestage_quota, kyn_tq2com_product, and  kyn_tq2com_account

-- deactivate current active
set active_flag = 0, active_end = ipl.acceptdate where active_flag = 1 for position and semiannual period

-- activate new
set active_flag = 0, active_start = ipl.acceptdate, active_end = 2200-01-01

*/

update ext.kyn_tq2com_prestage_quota set active_flag =0, active_start= null, active_end = null;

update ext.kyn_tq2com_prestage_quota q
set active_flag = 1, active_start = (
select acceptdate 
from ext.kyn_tq2com_ipl_trace ipl
where ipl.process_flag = 0
and ipl.status = 'status_Accepted'
and q.run_key = ipl.run_key 
and q.positionseq = ipl.positionseq
),
active_end = '2200-01-01'
where exists (
select 1 
from ext.kyn_tq2com_ipl_trace ipl
where ipl.process_flag = 0
and ipl.status = 'status_Accepted'
and q.run_key = ipl.run_key 
and q.positionseq = ipl.positionseq
);


update ext.kyn_tq2com_account q
set active_flag = 1, active_start = (
select acceptdate 
from ext.kyn_tq2com_ipl_trace ipl
where ipl.process_flag = 0
and ipl.status = 'status_Accepted'
and q.run_key = ipl.run_key 
and q.positionseq = ipl.positionseq
),
active_end = '2200-01-01'
where exists (
select 1 
from ext.kyn_tq2com_ipl_trace ipl
where ipl.process_flag = 0
and ipl.status = 'status_Accepted'
and q.run_key = ipl.run_key 
and q.positionseq = ipl.positionseq
);


update ext.kyn_tq2com_product q
set active_flag = 1, active_start = (
select acceptdate 
from ext.kyn_tq2com_ipl_trace ipl
where ipl.process_flag = 0
and ipl.status = 'status_Accepted'
and q.run_key = ipl.run_key 
and q.positionseq = ipl.positionseq
),
active_end = '2200-01-01'
where exists (
select 1 
from ext.kyn_tq2com_ipl_trace ipl
where ipl.process_flag = 0
and ipl.status = 'status_Accepted'
and q.run_key = ipl.run_key 
and q.positionseq = ipl.positionseq
);



-- set ipl flag

-- insert record into the vt_pipelineruns table to import the data





-- stage hook for txn assignments 
select x.run_key, x.position, x.territory, y.territory, x.classifierid, y.accountid 
from ext.kyn_tq2com_product x join ext.kyn_tq2com_account y on 
x.run_key = y.run_key
and x.territory = y.territory
where x.run_key = 98
order by x.position, x.territory, x.classifierid, y.accountid;


/***********************
 * Queries for example *
 ***********************/

-- good example
select s.run_key, s.territoryprogram_name, s.semiannual_name, x.position, x.territory, y.territory, x.classifierid, y.accountid, z.quotaname, z.value
from ext.kyn_tq2com_product x
join ext.kyn_tq2com_account y on x.run_key = y.run_key and x.territory = y.territory and x.positionseq = y.positionseq
join ext.kyn_tq2com_prestage_quota z on x.run_key = z.run_key and x.positionseq = z.positionseq
join ext.kyn_tq2com_sync s on x.run_key = s.run_key
where s.territoryprogram_name = 'FY24H1_AM_Seller_WW_DI'
and x.position = '5009345_GermanSchmidt_01';

-- this position is on plan "Plan2 - Signings_Revenue_Profit_MBO_6(Title)"

-- we can use this: "Plan1 Plan Document - Territory" - I ran it for the position

select pos.name, pos.effectivestartdate, pos.effectiveenddate, par.userid, par.participantemail
from cs_position pos 
join cs_participant par on pos.payeeseq = par.payeeseq and par.removedate = '2200-01-01'
where pos.removedate = '2200-01-01'
and par.islast = 1
and pos.islast = 1
and pos.name = '5009345_GermanSchmidt_01';



-- quota values
select * from ext.kyn_tq2com_prestage_quota where positionname = '5009345_GermanSchmidt_01' order by run_key;

select * from ext.kyn_tq2com_account where position = '5009345_GermanSchmidt_01';

select * from ext.kyn_tq2com_product where position = '5009345_GermanSchmidt_01';

-- worked example
select * from ext.kyn_tq2com_sync where territoryprogram_name = 'FY24H1_AM_Seller_WW_DI' order by run_key;

select * from ext.kyn_tq2com_tq_quota where run_key = 61 and position = '5009345_GermanSchmidt_01';

select * from ext.kyn_tq2com_prestage_quota where run_key = 61 and positionname = '5009345_GermanSchmidt_01' order by run_key, quotaname;

select * from ext.kyn_tq2com_account where run_key = 61 and position = '5009345_GermanSchmidt_01' order by run_key, accountid;

select * from ext.kyn_tq2com_product where run_key = 61 and position = '5009345_GermanSchmidt_01' order by run_key, accountid;


select * from ext.kyn_tq2com_ipl_trace where position = '5009345_GermanSchmidt_01' and run_key is not null order by generatedate;

select * from cs_stagequota where positionname = '5009345_GermanSchmidt_01' order by batchname, quotaname;

/*******
 * OLD *
 *******/




drop table ext.kyn_tq2com_com_quota;

-- commissions quotas
create table ext.KYN_TQ2Com_Com_Quota as (
select
per.startdate as effectivestartdate, per.enddate as effectiveenddate,
quo.name quotaname, fv.value, ut.name as unittypeforvalue, pt.name periodtypename, 
null as businessunitmap, pos.name positionname
from 
cs_quota quo
join cs_calendar cal on quo.calendarseq = cal.calendarseq and cal.removedate = to_date('22000101','yyyymmdd') 
--left outer join cs_businessunit bu on bitand(quo.businessunitmap,bu.mask) > 0
join cs_unittype ut on quo.unittypeseq = ut.unittypeseq and ut.removedate = to_date('22000101','yyyymmdd')
join cs_quota_variables qv on
  quo.quotaseq = qv.quotaseq
  and qv.effectivestartdate < quo.effectiveenddate
  and qv.effectiveenddate > quo.effectivestartdate
  and qv.removedate = to_date('22000101','yyyymmdd')
  and quo.removedate = to_date('22000101','yyyymmdd')
  and qv.modelseq = 0
join cs_variableassignment vas on
  qv.variableseq = vas.variableseq
  and qv.effectivestartdate < vas.effectiveenddate
  and qv.effectiveenddate > vas.effectivestartdate
  and vas.removedate = to_date('22000101','yyyymmdd')
  and vas.modelseq = 0
join cs_fixedvalue fv on
  fv.ruleelementseq = vas.assignmentseq
  and fv.effectivestartdate < vas.effectiveenddate
  and fv.effectiveenddate > vas.effectivestartdate 
  and fv.removedate = to_date('22000101','yyyymmdd')
  and fv.modelseq = 0
join cs_periodtype pt on 
  fv.periodtypeseq = pt.periodtypeseq
  and pt.removedate = to_date('22000101','yyyymmdd')
join cs_position pos on
  pos.ruleelementownerseq = vas.ruleelementownerseq 
  and pos.effectiveenddate   >= fv.effectiveenddate 
  and pos.effectivestartdate <  fv.effectiveenddate
  and pos.removedate = to_date('22000101','yyyymmdd')
  and pos.effectivestartdate = vas.effectivestartdate
join cs_period per on
  fv.periodtypeseq = per.periodtypeseq
  and per.startdate < fv.effectiveenddate
  and per.enddate > fv.effectivestartdate
  and per.removedate = to_date('22000101','yyyymmdd')
  and per.calendarseq = cal.calendarseq
join cs_processingunit pu on
  pos.processingunitseq = pu.processingunitseq  
where quo.modelseq = 0
);

-- differences comparison
select * from ext.kyn_tq2com_prestage_quota
where (effectivestartdate, effectiveenddate, quotaname, value, unittypeforvalue, periodtypename, businessunitmap,positionname ) 
not in (select * from ext.kyn_tq2com_com_quota);

delete from cs_stagequota where batchname like 'JC_TEST%'; -- and stageprocessflag = 0;

-- then insert into stage the differences 
-- we use one batch and set the stageprocess flag to 2 -- THIS DOES NOT WORK
-- I tried using flag 1 and it just revalidates all the records
-- we must update the batch of all the records eligible for import and then import them - we put the batchname into description to tie the records back
insert into cs_stagequota
(tenantid, stagequotaseq, effectivestartdate, effectiveenddate, quotaname, value, unittypeforvalue, periodtypename, businessunitmap, positionname, batchname, stageprocessflag, description)
select '1681' as tenantid,
(select max(stagequotaseq) from cs_stagequota) + row_number() over (order by quotaname, positionname) as stagequotaseq,
jc.*, 0 as stageprocessflag, 
jc.batchname as description
from ext.kyn_tq2com_prestage_quota jc
where (effectivestartdate, effectiveenddate, quotaname, value, unittypeforvalue, periodtypename, businessunitmap,positionname ) 
not in (select * from ext.kyn_tq2com_com_quota);

commit;

select * from cs_stagequota order by 2 desc;

-- IPL generate needs to use the stage records for the latest batch in the stage table -- we need a function to provide the details
-- minimum quota LT_Minimum_Quota
-- please see https://blogs.sap.com/2023/01/24/display-custom-data-in-a-spm-plan-communicator-document/
-- COnfirm with Peter how we should do this
select * from (
select rank() over (order by jc.run_key desc) as rn, x.*
from cs_stagequota x
join jc_quota_sync jc on x.description = jc.stagequota_batchname
where x.positionname = 'PL2006_MGRMCE_001'
and semiannual_name = 'HY1 2023'
) where rn = 1;


-- when IPL is accepted then import the stage records for the position
-- stage records
select max(stagequotaseq) as maxseq, batchname, stageprocessflag, count(*) 
from cs_stagequota 
where batchname like 'JC_TEST%' 
and stageprocessflag = 0
group by batchname, stageprocessflag
order by 1 desc;




select dt.name as dt_name, re.description as re_desc
from 
csp_documenttemplate dt
join CSP_DOCUMENTRULEELEMENTREFS drr on dt.documenttemplateseq = drr.documenttemplateseq and drr.removedate = '2200-01-01'
join cs_ruleelement re on drr.ruleelementseq = re.ruleelementseq and re.removedate = '2200-01-01'
where dt.removedate = '2200-01-01';

-- the link is the batch with max date prior to the generation date of the document
select sq.positioname, max(sq.batchname) as batchname
from (
select distinct batchname, positionname, to_seconddate(substr(batchname, instr(batchname, '#',-1)+1),'YYYYMMDD_HH24MISS') as stagedate
from cs_stagequota
) sq
join csp_documentprocess dp on 
  dp.generatedate >= sq.stagedate -- generated after the stage records were created
join cs_position pos on 
  dp.positionseq = pos.ruleelementownerseq
  and pos.removedate = '2200-01-01'
  and pos.effectivestartdate < dp.enddate
  and pos.effectiveenddate >= dp.enddate
  and pos.name = sq.positionname
where sq.batchname like 'JC_TEST#%'
group by sq.positioname;

-- after the semi annual quotas have been imported we need to ensure the annual quotas are correct - this can be done purely on commissions data - i.e. take both halves of the year and agregate up to annual. Check with Peter if this is correct.

-- TP3 and TP4 will now be split into multiple programs due to a security issue with T&Q

-- work with deepan.shanmugam.chandrasekar@sap.com


-- stage hook for txn assignments 
select x.run_key, x.position, x.territory, y.territory, x.classifierid, y.accountid 
from ext.kyn_tq2com_product x join ext.kyn_tq2com_account y on 
x.run_key = y.run_key
and x.territory = y.territory
where x.run_key = 98
order by x.position, x.territory, x.classifierid, y.accountid;



/************
 * Queries *
 ***********/
 
 
-- plan communicator details
select
dw.documentprocesstemplateseq,
dw.name as dw_name, cast(dw.effectivestartdate as date) as dw_esd, cast(dw.effectiveenddate as date) as dw_eed, dw.status as dw_status,
dp.generatedate dp_generatedate, dp.name dp_name, dp.batchname, dp.startdate dp_startdate, dp.enddate dp_enddate,
dp.positionseq, pos.name as position, dp.status dp_status,  dp.acceptdate dp_acceptdate,
dt.name dt_name, cast(dt.effectivestartdate as date) dt_esd, cast(dt.effectiveenddate as date) dt_edd, dty.datatype
from csp_documentworkflow dw 
join csp_documentprocess dp on dw.documentprocesstemplateseq = dp.documentprocesstemplateseq and dw.removedate = '2200-01-01'
join csp_documentassignment da on 
  dp.documentprocesstemplateseq = da.documentprocesstemplateseq 
  and da.removedate = '2200-01-01'
join csp_documenttemplate dt on 
  da.documenttemplateseq = dt.documenttemplateseq 
  and dt.removedate = '2200-01-01'
join csp_documenttype dty on
  dt.documenttypeseq = dty.datatypeseq
  and dty.removedate = '2200-01-01'
join cs_position pos on 
  dp.positionseq = pos.ruleelementownerseq 
  and pos.removedate = '2200-01-01' 
  and pos.effectivestartdate < dp.enddate 
  and pos.effectiveenddate >= dp.enddate
order by dp.generatedate desc, pos.name
;


-- to get semi annual values we don't need the granular values
select
  tp.name as program,
  cast(tp.effectivestartdate as date) as tp_esd,
  cast(tp.effectiveenddate as date) as tp_eed,
  pt.name as program_periodtype,
  per_tp.name as program_period,
  t.name as territory,
  cast(t.effectivestartdate as date) as t_esd,
  cast(t.effectiveenddate as date) as t_eed,  
  tt.targettypeid,
  tq.quotavalue,
  tq.finalquotavalue,
  tq.casestatus,
  cast(tq.effectivestartdate as date) as tq_esd,
  cast(tq.effectiveenddate as date) as tq_eed,
  cast(tpos.effectivestartdate as date) as tpos_esd,
  cast(tpos.effectiveenddate as date) as tpos_eed,
  tpos.split,
  pos.name as position,
  cast(pos.effectivestartdate as date) as pos_esd,
  cast(pos.effectiveenddate as date) as pos_eed,
  pos.payeeseq,
  pay.payeeid,
  cast(pay.effectivestartdate as date) as pay_esd,
  cast(pay.effectiveenddate as date) as pay_eed
from CSQ_TerritoryProgram tp
left outer join cs_periodtype pt on tp.periodtypeseq = pt.periodtypeseq and pt.removedate= '2200-01-01'
left outer join cs_period per_tp on tp.periodseq = per_tp.periodseq and per_tp.removedate= '2200-01-01'
left outer join csq_territory t on 
  tp.territoryprogramseq = t.territoryprogramseq
  and t.removedate = '2200-01-01'
  and t.effectivestartdate < tp.effectiveenddate
  and t.effectiveenddate > tp.effectivestartdate 
left outer join csq_territoryquota tq on 
  tq.territoryseq = t.territoryseq 
  and tq.removedate= '2200-01-01' 
  and tq.effectivestartdate < t.effectiveenddate
  and tq.effectiveenddate > t.effectivestartdate 
left outer join csq_targettype tt on tq.targettypeseq = tt.datatypeseq and tt.removedate= '2200-01-01'
left outer join cs_unittype ut_tq on tq.unittypeforquotavalue = ut_tq.unittypeseq and ut_tq.removedate = '2200-01-01'
left outer join csq_territoryposition tpos on 
  tpos.territoryseq = t.territoryseq 
  and tpos.removedate = '2200-01-01' 
  and tpos.effectivestartdate < t.effectiveenddate
  and tpos.effectiveenddate > t.effectivestartdate 
left outer join cs_position pos on 
  tpos.positionseq = pos.ruleelementownerseq 
  and pos.removedate = '2200-01-01'
  and pos.effectivestartdate < tpos.effectiveenddate
  and pos.effectiveenddate >= tpos.effectiveenddate
left outer join cs_payee pay on
  pos.payeeseq = pay.payeeseq
  and pay.removedate = '2200-01-01'
  and pay.effectivestartdate < pos.effectiveenddate
  and pay.effectiveenddate >= pos.effectiveenddate
  where tp.removedate = '2200-01-01'
  and tp.name = 'FY24H1_AM_Seller_WW_DI'
  and t.name = 'SellerAMRole0033'
  and pos.name = 'PL1001_Iberia'
  --  and per.name = 'April 2022'
  --and tqc.isquotasetting = 0 -- prevent duplicates
  --and tqc.periodseq is not null
  --and tqc.value is not null -- only values  
  --and tt.targettypeid = 'Revenue'
  --and per.periodtypeseq = tp.periodtypeseq -- only quota cell values for the relevant periodtype
  --and exists (select 1 from cs_quota q where q.removedate = '2200-01-01' and q.name = tt.targettypeid)
  order by tp.name, per_tp.name, t.name, tt.targettypeid, pos.name;

-- T&Q quotas breakdown
select
  tp.name as program,
  cast(tp.effectivestartdate as date) as tp_esd,
  cast(tp.effectiveenddate as date) as tp_eed,
  pt.name as program_periodtype,
  per_tp.name as program_period,
  t.name as territory,
  cast(t.effectivestartdate as date) as t_esd,
  cast(t.effectiveenddate as date) as t_eed,  
  tt.targettypeid,
  tq.quotavalue,
  tq.finalquotavalue,
  tq.casestatus,
  cast(tq.effectivestartdate as date) as tq_esd,
  cast(tq.effectiveenddate as date) as tq_eed,
  per.name as tqc_period,  
  cast(tqc.effectivestartdate as date) as tqc_esd,
  cast(tqc.effectiveenddate as date) as tqc_eed,
  tqc.value as tqc_value,
  ut_tqc.name as tqc_unittype,
  tqc.isquotasetting,
  cast(tpos.effectivestartdate as date) as tpos_esd,
  cast(tpos.effectiveenddate as date) as tpos_eed,
  tpos.split,
  pos.name as position,
  cast(pos.effectivestartdate as date) as pos_esd,
  cast(pos.effectiveenddate as date) as pos_eed,
  pos.payeeseq,
  pay.payeeid,
  cast(pay.effectivestartdate as date) as pay_esd,
  cast(pay.effectiveenddate as date) as pay_eed
from CSQ_TerritoryProgram tp
left outer join cs_periodtype pt on tp.periodtypeseq = pt.periodtypeseq and pt.removedate= '2200-01-01'
left outer join cs_period per_tp on tp.periodseq = per_tp.periodseq and per_tp.removedate= '2200-01-01'
left outer join csq_territory t on 
  tp.territoryprogramseq = t.territoryprogramseq
  and t.removedate = '2200-01-01'
  and t.effectivestartdate < tp.effectiveenddate
  and t.effectiveenddate > tp.effectivestartdate 
left outer join csq_territoryquota tq on 
  tq.territoryseq = t.territoryseq 
  and tq.removedate= '2200-01-01' 
  and tq.effectivestartdate < t.effectiveenddate
  and tq.effectiveenddate > t.effectivestartdate 
left outer join csq_targettype tt on tq.targettypeseq = tt.datatypeseq and tt.removedate= '2200-01-01'
left outer join cs_unittype ut_tq on tq.unittypeforquotavalue = ut_tq.unittypeseq and ut_tq.removedate = '2200-01-01'
left outer join csq_territoryposition tpos on 
  tpos.territoryseq = t.territoryseq 
  and tpos.removedate = '2200-01-01' 
  and tpos.effectivestartdate < t.effectiveenddate
  and tpos.effectiveenddate > t.effectivestartdate 
left outer join cs_position pos on 
  tpos.positionseq = pos.ruleelementownerseq 
  and pos.removedate = '2200-01-01'
  and pos.effectivestartdate < tpos.effectiveenddate
  and pos.effectiveenddate >= tpos.effectiveenddate
left outer join cs_payee pay on
  pos.payeeseq = pay.payeeseq
  and pay.removedate = '2200-01-01'
  and pay.effectivestartdate < pos.effectiveenddate
  and pay.effectiveenddate >= pos.effectiveenddate
left outer join csq_territoryquotacell tqc on 
  tqc.territoryquotaseq = tq.territoryquotaseq 
  and tqc.removedate = '2200-01-01' 
  and tqc.effectivestartdate < tq.effectiveenddate
  and tqc.effectiveenddate > tq.effectivestartdate 
left outer join cs_period per on tqc.periodseq = per.periodseq and per.removedate = '2200-01-01'
left outer join cs_unittype ut_tqc on tqc.unittypeforvalue = ut_tqc.unittypeseq and ut_tqc.removedate = '2200-01-01'
  where tp.removedate = '2200-01-01'
  and tp.name = 'FY24H1_AM_Seller_WW_DI'
  and t.name = 'SellerAMRole0033'
  and pos.name = 'PL1001_Iberia'
  --  and per.name = 'April 2022'
  --and tqc.isquotasetting = 0 -- prevent duplicates
  --and tqc.periodseq is not null
  --and tqc.value is not null -- only values  
  --and tt.targettypeid = 'Revenue'
  --and per.periodtypeseq = tp.periodtypeseq -- only quota cell values for the relevant periodtype
  --and exists (select 1 from cs_quota q where q.removedate = '2200-01-01' and q.name = tt.targettypeid)
  order by tp.name, per_tp.name, t.name, tt.targettypeid, pos.name, per.name;
  
  
  
  
-- Commissions Quotas
-- quota period types
select quo.name as quota, qpt.name as periodtype
from cs_quota quo
join cs_quota_variables qv on
  quo.quotaseq = qv.quotaseq
  and qv.effectivestartdate < quo.effectiveenddate
  and qv.effectiveenddate > quo.effectivestartdate
  and qv.removedate = to_date('22000101','yyyymmdd')
  and qv.modelseq = 0
join cs_variable var on
  qv.variableseq = var.ruleelementseq
  and var.effectivestartdate < qv.effectiveenddate
  and var.effectiveenddate > qv.effectivestartdate
  and var.removedate = to_date('22000101','yyyymmdd')
join cs_periodtype qpt on 
  var.periodtypeseq = qpt.periodtypeseq 
  and qpt.removedate = to_date('22000101','yyyymmdd')
where quo.removedate = to_date('22000101','yyyymmdd')
and quo.modelseq = 0
order by 1,2;

-- quotas
select
quo.name quota_name,
--IFNULL(bu.name,to_char(quo.businessunitmap)) as bu_name, 
quo.description,
cal.name as calendar_name,
ut.name as unittype,
pos.name position_name, pu.name as pu_name, 
pos.effectivestartdate, pos.effectiveenddate,
pt.name period_type, per.name period_name, fv.value 
from 
cs_quota quo
join cs_calendar cal on quo.calendarseq = cal.calendarseq and cal.removedate = to_date('22000101','yyyymmdd') 
--left outer join cs_businessunit bu on bitand(quo.businessunitmap,bu.mask) > 0
join cs_unittype ut on quo.unittypeseq = ut.unittypeseq and ut.removedate = to_date('22000101','yyyymmdd')
join cs_quota_variables qv on
  quo.quotaseq = qv.quotaseq
  and qv.effectivestartdate < quo.effectiveenddate
  and qv.effectiveenddate > quo.effectivestartdate
  and qv.removedate = to_date('22000101','yyyymmdd')
  and quo.removedate = to_date('22000101','yyyymmdd')
  and qv.modelseq = 0
join cs_variableassignment vas on
  qv.variableseq = vas.variableseq
  and qv.effectivestartdate < vas.effectiveenddate
  and qv.effectiveenddate > vas.effectivestartdate
  and vas.removedate = to_date('22000101','yyyymmdd')
  and vas.modelseq = 0
join cs_fixedvalue fv on
  fv.ruleelementseq = vas.assignmentseq
  and fv.effectivestartdate < vas.effectiveenddate
  and fv.effectiveenddate > vas.effectivestartdate 
  and fv.removedate = to_date('22000101','yyyymmdd')
  and fv.modelseq = 0
join cs_periodtype pt on 
  fv.periodtypeseq = pt.periodtypeseq
  and pt.removedate = to_date('22000101','yyyymmdd')
join cs_position pos on
  pos.ruleelementownerseq = vas.ruleelementownerseq 
  and pos.effectiveenddate   >= fv.effectiveenddate 
  and pos.effectivestartdate <  fv.effectiveenddate
  and pos.removedate = to_date('22000101','yyyymmdd')
  and pos.effectivestartdate = vas.effectivestartdate
join cs_period per on
  fv.periodtypeseq = per.periodtypeseq
  and per.startdate < fv.effectiveenddate
  and per.enddate > fv.effectivestartdate
  and per.removedate = to_date('22000101','yyyymmdd')
  and per.calendarseq = cal.calendarseq
join cs_processingunit pu on
  pos.processingunitseq = pu.processingunitseq  
where quo.modelseq = 0
  --and per.name like '%2023%'
  and pos.name = 'PL1001_Iberia'
--  and fv.value is not null
--  and pu.name = 'Retail'
--and pos.name like '012345678A_Account Management Partner'
order by quo.name, pos.name, per.startdate, per.periodseq;



-- search for quota seq

create table jc_test (table_name varchar(127), column_name varchar(127), row_count integer);

do begin
declare cursor c_sql for 
select table_name, column_name, 
'insert into jc_test select :1 as table_name, :2 as column_name, count(*) from '||table_name||' where '||column_name||'=39969446692913154'  as sql_text
from table_columns where column_name like '%SEQ' and schema_name='TCMP' and table_name like 'CS$_%' escape '$'
order by table_name, column_name;
delete from jc_test;
for x as c_sql
do
execute immediate :x.sql_text using x.table_name, x.column_name;
end for;
end;




insert into ext.kyn_tq2com_prestage_quota (select * from (
select
qs.run_key,
qs.semiannual_periodseq,
qs.semiannual_name,
cast(0 as tinyint) as active_flag,
cast(null as timestamp) as active_start,
cast(null as timestamp) as active_end,
per.startdate as effectivestartdate,
per.enddate as effectiveenddate,
case jc.targettypeid
when 'GP' then 'Q_Profit'
else 'Q_'||jc.targettypeid
end as quotaname,
sum(jc.quotavalue) as value,
jc.unittype as unittypeforvalue,
pt.name as periodtypename,
null as businessunitmap,
jc.positionseq,
jc.position as positionname,
null as batchname
from ext.kyn_tq2com_tq_quota jc
join ext.kyn_tq2com_sync qs on jc.run_key = qs.run_key
join cs_period per on qs.semiannual_periodseq = per.periodseq and per.removedate = '2200-01-01'
join cs_periodtype pt on per.periodtypeseq = pt.periodtypeseq and pt.removedate = '2200-01-01'
where qs.process_flag = 0
group by qs.run_key, qs.semiannual_periodseq, qs.semiannual_name, per.startdate, per.enddate, jc.targettypeid, jc.unittype, pt.name, jc.positionseq, jc.position
) x
where exists (select 1 from cs_quota q where q.removedate ='2200-01-01' and x.quotaname = q.name)
);




select rm.name, md_country.name, mi.minstring, mi.effectivestartdate as index_effectivestartdate,
mi.effectiveenddate as index_effectiveenddate, mc.effectivestartdate as cell_effectivestartdate,
mc.effectiveenddate as cell_effectiveenddate
from cs_relationalmdlt rm
inner join cs_mdltdimension md_country
on md.ruleelementseq = rm.ruleelementseq
inner join cs_mdltdimension md_country
on md.ruleelementseq = rm.ruleelementseq
inner join cs_mdltindex mi
on md.ruleelementseq = mi.ruleelementseq
and mi.ruleelementseq = rm.ruleelementseq
inner join cs_mdltcell mc
on mc.mdltseq = mi.ruleelementseq
and mc.mdltseq = rm.ruleelementseq
and mc.mdltseq = md.ruleelementseq
where rm.name ='LT_Minimum_Quota'
and rm.removedate > current_timestamp
and md.removedate > current_timestamp
and mi.removedate > current_timestamp
and mc.removedate > current_timestamp
and md_country.name='Country';







select rm.name, md_country.name, 
md_element.name, md_periodCycle.name,
mi_country.minstring
mi_element.minstring,mi_periodCycle.minstring
from cs_relationalmdlt rm

inner join cs_mdltdimension md_country
on md_country.ruleelementseq = rm.ruleelementseq

inner join cs_mdltdimension md_element
on md_element.ruleelementseq = rm.ruleelementseq
and md_element.ruleelementseq = md_country.ruleelementseq

inner join cs_mdltdimension md_periodCycle
on md_periodCycle.ruleelementseq = rm.ruleelementseq
and md_periodCycle.ruleelementseq = md_element.ruleelementseq
and md_periodCycle.ruleelementseq = md_country.ruleelementseq

inner join cs_mdltindex mi_country
on md_country.ruleelementseq = mi_country.ruleelementseq
and md_element.ruleelementseq = mi_country.ruleelementseq
and md_periodCycle.ruleelementseq = mi_country.ruleelementseq
and rm.ruleelementseq= mi_country.ruleelementseq

inner join cs_mdltindex mi_element
on md_element.ruleelementseq = mi_element.ruleelementseq
and md_country.ruleelementseq = mi_element.ruleelementseq
and md_periodCycle.ruleelementseq = mi_element.ruleelementseq
and rm.ruleelementseq= mi_element.ruleelementseq


inner join cs_mdltindex mi_periodCycle
on md_periodCycle.ruleelementseq = mi_periodCycle.ruleelementseq
and md_element.ruleelementseq = mi_periodCycle.ruleelementseq
and md_periodCycle.ruleelementseq = mi_periodCycle.ruleelementseq
and rm.ruleelementseq= mi_periodCycle.ruleelementseq

inner join cs_mdltcell mc_country
on mc_country.mdltseq = mi_country.ruleelementseq
and mc_country.mdltseq = rm.ruleelementseq
and mc_country.mdltseq = md_country.ruleelementseq
and mc_country.mdltseq = md_element.ruleelementseq
and mc_country.mdltseq = md_periodCycle.ruleelementseq

inner join cs_mdltcell mc_element
on mc_element.mdltseq = mi_element.ruleelementseq
and mc_element.mdltseq = rm.ruleelementseq
and mc_element.mdltseq = md_element.ruleelementseq
and mc_element.mdltseq = md_periodCycle.ruleelementseq
and mc_element.mdltseq = md_country.ruleelementseq
and mc_element.mdltseq = mc_country.mdltseq

inner join cs_mdltcell mc_periodCycle
on mc_periodCycle.mdltseq = mi_periodCycle.ruleelementseq
and mc_periodCycle.mdltseq = rm.ruleelementseq
and mc_periodCycle.mdltseq = md_periodCycle.ruleelementseq
and mc_periodCycle.mdltseq = md_element.ruleelementseq
and mc_periodCycle.mdltseq = md_country.ruleelementseq
and mc_periodCycle.mdltseq = mc_country.mdltseq
and mc_periodCycle.mdltseq = mc_element.mdltseq


where rm.name ='LT_Minimum_Quota'
and rm.removedate > current_timestamp
and md_country.removedate > current_timestamp
and md_periodCycle.removedate > current_timestamp
and md_element.removedate > current_timestamp
and mi_country.removedate > current_timestamp
and mi_element.removedate > current_timestamp
and mi_periodCycle.removedate > current_timestamp
and mc_element.removedate > current_timestamp
and mc_periodCycle.removedate > current_timestamp
and mc_country.removedate > current_timestamp
and md_country.name='Country'
and md_periodCycle.name='Period Cycle'
and md_element.name='Element'
;


##############Final#########################################

select COUNTRY_ELEMENT.*, mi.*, mc.* from (select country.NAME as country_name , country.DIM1index as DIM1INDEX, mi.minstring as element_name, mc.mdltcellseq as mdltcellseq,
mc.DIM2index as DIM2INDEX
from (select  mi.minstring as NAME, mc.mdltcellseq, mc.DIM1index from cs_mdltcell mc
inner join cs_relationalmdlt rm
on mc.mdltseq=rm.ruleelementseq

inner join cs_mdltindex mi 
on mi.ordinal= mc.dim0index
and mi.ruleelementseq=rm.ruleelementseq
and mi.ruleelementseq=mc.mdltseq

inner join cs_mdltdimension md
on md.dimensionseq=mi.dimensionseq
and md.ruleelementseq=rm.ruleelementseq
and md.ruleelementseq=mi.ruleelementseq

where rm.name ='LT_Minimum_Quota'
and md.name='Country'
and mi.minstring='AE'
and rm.removedate > current_timestamp
and mc.removedate > current_timestamp 
and mi.removedate > current_timestamp 
and md.removedate > current_timestamp 
) COUNTRY

inner join cs_mdltcell mc
on mc.mdltcellseq = country.mdltcellseq

inner join cs_relationalmdlt rm
on mc.mdltseq=rm.ruleelementseq

inner join cs_mdltindex mi 
on mi.ordinal= mc.dim1index
and mi.ruleelementseq=rm.ruleelementseq
and mi.ruleelementseq=mc.mdltseq

inner join cs_mdltdimension md
on md.dimensionseq=mi.dimensionseq
and md.ruleelementseq=rm.ruleelementseq
and md.ruleelementseq=mi.ruleelementseq

where rm.name ='LT_Minimum_Quota'
and md.name='Element'
and mi.minstring='Profit'
and rm.removedate > current_timestamp
and mc.removedate > current_timestamp 
and mi.removedate > current_timestamp 
and md.removedate > current_timestamp ) COUNTRY_ELEMENT
inner join cs_mdltcell mc
on mc.mdltcellseq = COUNTRY_ELEMENT.mdltcellseq

inner join cs_relationalmdlt rm
on mc.mdltseq=rm.ruleelementseq

inner join cs_mdltindex mi 
on mi.ordinal= mc.dim2index
and mi.ruleelementseq=rm.ruleelementseq
and mi.ruleelementseq=mc.mdltseq

inner join cs_mdltdimension md
on md.dimensionseq=mi.dimensionseq
and md.ruleelementseq=rm.ruleelementseq
and md.ruleelementseq=mi.ruleelementseq

where rm.name ='LT_Minimum_Quota'
and md.name='Period Cycle'
and mi.minvalue in (1)
and rm.removedate > current_timestamp
and mc.removedate > current_timestamp 
and mi.removedate > current_timestamp 
and md.removedate > current_timestamp 
;
